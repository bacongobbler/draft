+++
dep = 5
title = "Draft Plugin Format"
authors = [ "Matt Fisher <matt.fisher@microsoft.com>" ]
created = 2017-10-23
+++

# Introduction

A plugin is a tool that can be accessed through the `draft` CLI, but is not part of the built-in Draft codebase.

# Abstract

Draft plugins are add-on tools that integrate seamlessly with Draft. They provide a way to extend the core feature set of the Draft client without requiring every new feature to be added to the core tool.

Draft plugins have the following features:

- They can be added and removed from a Draft installation without impacting the core Draft tool.
- They can be written in any programming language.
- They integrate with Draft, and will show up in `draft help` and other places.

Draft plugins live in `$(draft home)/plugins`.

The Draft plugin model is partially modeled on Git's plugin model. To that end, you may sometimes hear `draft` referred to as the _porcelain_ layer, with plugins being the _plumbing_. This is a shorthand way of suggesting that Draft provides the user experience and top level processing logic, while the plugins do the "detail work" of performing a desired action.

# Using Plugins

## Installing a Plugin

Plugins are installed using `draft plugin install <name>`. You can pass in the name of a plugin.

## Finding Plugins

Plugins can be discovered through `draft plugin search`.

```console
$ draft plugin search
NAME            REPOSITORY                      VERSION
pack-repo       github.com/draftcreate/plugins  0.4.2
```

Searching for certain plugins can be done by providing mulitple keywords. `draft plugin search` searches
for plugins with similar names using fuzzy string search.

```console
$ draft plugin search rep
NAME            REPOSITORY                      VERSION
pack-repo       github.com/draftcreate/plugins  0.4.2
```

## Building Plugins

A plugin is composed of two different entities:

1. A Lua script, defining metadata about the plugin
2. A compressed file (.tar, .tar.gz, .zip) or an executable (.exe, static binary)

Plugin Lua scripts can be generated using `draft plugin create <name>`. Plugin Lua scripts are
placed under `$(draft home)/plugins/repositories/github.com/draftcreate/plugins/Plugins/name.lua`
and the file name is displayed on stdout such that it can be piped to your editor of choice. For example,

```shell
$ vim $(draft plugin create foo)
```

One can imagine the contents of a plugin having the following directory structure:

```shell
$(draft home)/plugins/
  |- keybase/
      |- 0.1.0/
          |
          |- keybase
```

In the example above, the `keybase` plugin is contained inside of a directory named `keybase`. It has one executable: `keybase`. On Windows, the plugin executable may be named `keybase.exe`, but that is determined by the plugin distributor and the `path` field explained further below.

The core of a plugin is a Lua script contained within a plugin repository. It contains some basic metadata on the plugin's description, name and version number as well as how `draft` can fetch and unpack the executable.

Here is an example Lua script for a plugin that adds support for Keybase operations:

```lua
local name = "keybase"
local version = "0.1.0"

plugin = {
    name = name,
    description = "Integrate Keybase.io tools with Draft",
    homepage = "https://github.com/Azure/draft",
    version = version,
    useTunnel = false,
    packages = {
        {
            os = "darwin",
            arch = "amd64",
            url = "https://azuredraft.blob.core.windows.net/draft/" .. name .. "-v" .. version .. "-darwin-amd64.tar.gz",
            sha256 = "b6169582b3204ee6eb23640728c91c7eddfecb1d64976c09ae2959d67d3b658f",
            path = name .. ".sh",
        },
        {
            os = "linux",
            arch = "amd64",
            url = "https://azuredraft.blob.core.windows.net/draft/" .. name .. "-v" .. version .. "-linux-amd64.tar.gz",
            sha256 = "4cbab465ce2a53eefe918f6eccc604155354228759f433f94b1b9704ae8150a2",
            path = name .. ".sh",
        },
        {
            os = "windows",
            arch = "amd64",
            url = "https://azuredraft.blob.core.windows.net/draft/" .. name .. "-v" .. version .. "-windows-amd64.tar.gz",
            sha256 = "fd07836a937a1afebd6e834bd487d84c8b9def78b9012286b179bc54d4bfe763",
            path = name .. ".ps1",
        }
    }
}
```

The `name` is the name of the plugin. When Draft executes the plugin, this is the name it will use (e.g. `draft NAME` will invoke this plugin).

Restrictions on `name`:

- `name` cannot duplicate one of the existing `draft` top-level commands.
- `name` must be restricted to the characters ASCII a-z, A-Z, 0-9, `_` and `-`.

`version` is the SemVer 2 version of the plugin.

`description` is used to generate the help text of a command.

The `useTunnel` switch indicates that the plugin needs a tunnel to Tiller. This should be set to `true` _anytime a plugin talks to tiller_. It will cause Draft to open a tunnel, and then set `$HELM_HOST` to the right local address for that tunnel.

`packages` defines how the plugin is packaged for each operating system (Windows, macOS, Linux, ARM, etc.) and each architecture (i386, amd64, ppc64le, etc.).

`os` and `arch` is the operating system and architecture the package is compiled for. For macOS, the convention is to use `darwin` as the os.

`url` is the link to the compressed archive containing the plugin.

`sha256` is the computed checksum of the compressed archive.

Finally, and most importantly, `path` is the command that this plugin will execute when it is called. `path` is relative to the root of the compressed archive containing the plugin. Environment variables are interpolated before the plugin is executed. The pattern above illustrates the preferred way to indicate where the plugin program lives.

There are some strategies for working with plugin commands:

- Draft injects lots of configuration into environment variables. Take a look at
  the environment to see what information is available (hint: use `draft plugin install env` to help expose this information).
- Draft makes no assumptions about the language or environment of the plugin. You can write it in whatever language you prefer, however be cognizant of the fact that many users are running Draft on Windows, macOS and Linux.
- Commands are responsible for implementing specific help text for `-h` and `--help`.
  Draft will use `usage` and `description` for `draft help` and `draft help myplugin`,
  but will not handle `draft myplugin --help`.

## Environment Variables

When Draft executes a plugin, it passes the outer environment to the plugin, and also injects some additional environment variables.

Variables like `KUBECONFIG` are set for the plugin if they are set in the outer environment.

The following variables are guaranteed to be set:

- `DRAFT_PLUGIN`: The path to the plugins directory
- `DRAFT_PLUGIN_NAME`: The name of the plugin, as invoked by `draft`. So
  `draft myplug` will have the short name `myplug`.
- `DRAFT_PLUGIN_DIR`: The directory that contains the plugin.
- `DRAFT_BIN`: The path to the `draft` command (as executed by the user).
- `DRAFT_HOME`: The path to the Draft home.
- `DRAFT_PACKS_PATH`: The path to the Draft starter packs.
- `HELM_HOST`: The `domain:port` to Tiller, if requested through the `useTunnel` flag.
  If a tunnel is created, this will point to the local endpoint for the tunnel.

While `HELM_HOST` _may_ be set, there is no guarantee that it will point to the correct Tiller instance. This is done to allow the plugin developer to access `HELM_HOST` in its raw state when the plugin itself needs to manually configure a connection.

## A Note on `useTunnel`

If a plugin specifies `useTunnel = true`, Draft will do the following (in order):

1. Parse global flags and the environment
1. Create the tunnel
1. Set `HELM_HOST`
1. Execute the plugin
1. Close the tunnel

The tunnel is removed as soon as the `command` returns. So, for example, a command cannot background a process and assume that that process will be able to use the tunnel.

## A Note on Flag Parsing

When executing a plugin, Draft will parse global flags for its own use. Some of these flags are _not_ passed on to the plugin.

- `--debug`: If this is specified, `$DRAFT_DEBUG` is set to `1`
- `--home`: This is converted to `$DRAFT_HOME`
- `--host`: This is converted to `$HELM_HOST`
- `--kube-context`: This is simply dropped. If your plugin uses `useTunnel`, this is used to set up the tunnel for you.

Plugins _should_ display help text and then exit for `-h` and `--help`. In all other cases, plugins may use flags as appropriate.

# How to Create and Maintain a Plugin Repository

Plugin Repositories are external sources of Draft plugins maintained by the community. They can be created by anyone to provide their own plugins outside of core for use by any Draft user.

A repository is usually a Git repository available online, but you can use a local directory, a mercurial or subversion repository as well! If hosted on GitHub, we recommend that the repository’s name starts with `draft-plugins`, but it is not enforced.

Plugins follow the same format as the core’s ones, and can be added under the `Plugins/` subdirectory. We enforce this approach because it makes the repository organisation easier to grasp, and top-level files are not mixed with plugin metadata.

See [draftcreate/plugins][plugin-core] for an example of a repository with a `Plugins/` subdirectory.

## Using a Plugin Repository

If it’s on GitHub, users can consume your plugin repository using `draft plugin repository add https://github.com/user/draft-plugins`, where user is your GitHub username and `draft-plugins` is the name of your repository.

Users can then install your plugins either with `draft plugin install foo` if there’s no core plugins with the same name, or with `draft plugin install github.com/user/draft-plugins/foo` to avoid conflicts.

## Maintaining a Plugin Repository

A repository is just a Git repository, so you don’t have to do anything specific when making modifications, apart from committing and pushing your changes.

Once your repository is installed, Draft will update it each time a user runs `draft plugin update` (or with `draft plugin upgrade` as an implicit action). Outdated plugins will be upgraded when a user runs `draft plugin upgrade`.

# Reference Implementation

Exisiting plugins can be found in the [draft plugin core repository][plugin-core], or by using `draft plugin search` once `draft init` has been called for the first time.

# Rationale

Prior versions of Draft relied on a git-based distribution model for installing and upgrading plugins, based on Helm plugins. This turned out to be problematic for distribution for several reasons:

- Plugin distributors were using install hooks to fetch a release distribution of the plugin
- Due to point 1, plugin distributors were having to re-implement fetch and unpacking the release distributions
- Because plugins were not in a centralized repository, plugins were not discoverable by users
- Certain fields in plugin.yaml (such as `command` and the hooks) were not cross-platform compatible


[plugin-core]: https://github.com/draftcreate/plugins
